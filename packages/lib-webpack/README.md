# `@openshift/dynamic-plugin-sdk-webpack`

> Allows building dynamic plugin assets with webpack.

## Sample configuration with server output enabled

Following sample configuration will output both, client (browser) version of assets as well as server compatible version of assets.

Server bundle will have its unique assets as well as unique plugin manifest file. All server compatible assets and manifest will have a `.server.js` file extension.

The `emitServer` marks the plugin eligible for server use.

```TS
import path from 'path';
import { DynamicRemotePlugin } from '@openshift/dynamic-plugin-sdk-webpack';
import type { WebpackSharedObject } from '@openshift/dynamic-plugin-sdk-webpack';
import type { Configuration, WebpackPluginInstance } from 'webpack';

const isProd = process.env.NODE_ENV === 'production';

const pathTo = (relativePath: string) => path.resolve(__dirname, relativePath);

const pluginSharedModules: WebpackSharedObject = {
  // the @openshift/dynamic-plugin-sdk is mandatory to be a singleton if it is consumed
  '@openshift/dynamic-plugin-sdk': { singleton: true, import: false },
  react: { singleton: true, import: false },
  'react-dom': { singleton: true, import: false },
  // other dependencies
};

const plugins: WebpackPluginInstance[] = [
  new DynamicRemotePlugin({
    moduleFederationSettings: {
      libraryType: 'global', // jsonp currently does not work with @module-federation/utilities
    },
    pluginMetadata, // standard plugin metadata config
    extensions, // standard plugin extensions config
    sharedModules: pluginSharedModules,
    entryScriptFilename: isProd ? 'plugin-entry.[fullhash].min.js' : 'plugin-entry.js',
    // If set to true, the DynamicRemotePlugin will emit additional assets for server usage as well as client
    emitServer: true, 
  }),
];

const config: Configuration = {
  mode: isProd ? 'production' : 'development',
  target: 'web',
  entry: {}, // Plugin container entry is generated by DynamicRemotePlugin
  output: {
    path: pathTo('dist'),
    /**
     * Public path is critical, if the assets are on the same origin, host does not have to be included. 
     * However the path has to end with trailing '/'
     * */    
    publicPath: 'http://localhost:9001/',
    chunkFilename: isProd ? 'chunks/[id].[chunkhash].min.js' : 'chunks/[id].js',
    assetModuleFilename: isProd ? 'assets/[contenthash][ext]' : 'assets/[name][ext]',
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
  },
  module: {
    rules: [
      // rule setup
    ],
  },
  // add the plugins
  plugins,
  // ...rest of the config
};

export default config;

```

## SSR usage

To use the skd bundle on server, following code si required:

```tsx
// we use the @module-federation/utilities as it contains the node env module federation compatible utilities
import { getContainer, injectScript } from '@module-federation/utilities';
import { PluginLoaderOptions, PluginStoreProvider } from '@openshift/dynamic-plugin-sdk';

const pluginLoaderOptions: PluginLoaderOptions = {
  injectScript: (url, manifest) => {
    // we need to customize the inject script method for node env as it cannot use the browser `script` tags to load new JS assets
    return injectScript({
      url, // the script URL returned by the SDK
      global: manifest.name // we can't use jsonp as of yet, the global will always match the plugin name
    })
  },
  // works well with the `injectScript` method from the utilities package
  getPluginEntryModule: (manifest) => getContainer(manifest.name),
}

// ensure the plugin store has SSR compatible loader options
const pluginStore = new PluginStore({
  loaderOptions: pluginLoaderOptions
})

// need some manifest map with both browser and server urls
const manifestMap = {
  'some-plugin': {
    browser: 'http://localhost:8888/plugin-manifest.json',
    server: 'http://localhost:8888/plugin-manifest.server.json'
  }
}

const loadPlugin = (manifestId: string) => {
  // we need some flag to detect node/browser runtime
  // webpack define plugin can be used for used usecase https://webpack.js.org/plugins/define-plugin/
  const isServer = process.env.IS_SERVER
  // pick correct manifest for runtime environment
  return pluginStore.loadPlugin(isServer
    ? manifestMap[manifestId].server
    : manifestMap[manifestId].browser
  )
}

// use somewhere in your application where it makes sense
loadPlugin('some-plugin')

const Root = () => {
  // initialize provider with created plugin store
  return (
    <PluginStoreProvider store={pluginStore}>
    {/** rest of the tree */}
    </PluginStoreProvider>
  )
}

export default Root

```